//
//  main.m
//  testCcode1
//
//  Created by 黄龙 on 2019/6/10.
//  Copyright © 2019年 adong. All rights reserved.
//

#import <UIKit/UIKit.h>
#import "AppDelegate.h"

int main(int argc, char * argv[]) {
    @autoreleasepool {
//        以指针的形式访问和以下标的形式访问
        char *p = "abcdef";
//        定义了一个指针变量p，p本身在栈上占4个byte,p里存储的是一块内存的首地址。这块内存在静态区，其空间大小为7 个byte，这块内存也没有名字。
//        对这块内存的访问完全是匿名的访问。比如现在需要读取字符‘e’，我们有两种方式:
//        1)以指针的形式：*(p+4)取，步骤为先取出p里存储的地址值，假设为0x0000FF00，然后加上4 个字符的偏移量，得到新的地址0x0000FF04。然后取出0x0000FF04 地址上的值
//        2)以下标的形式：p[4]取，这个操作会被解析成：先取出p 里存储的地址值，然后加上中括号中4 个元素的偏移量，计算出新的地址，然后从新的地址中取出值。
//        也就是说以下标的形式访问在本质上与以指针的形式访问没有区别，只是写法上不同罢了。
        printf("%c,%c",*(p+4),p[4]);//e,e
        
        char pa[] = "123456";
//        定义了一个数组pa，pa拥有7个char 类型的元素，其空间大小为7。数组pa本身在栈上面。
//        对pa的元素的访问必须先根据数组的名字pa找到数组首元素的首地址，然后根据偏移量找到相应的值。
//        这是一种典型的“具名+匿名”访问。比如现在需要读取字符‘5’，我们有两种方式：
//        1、以指针的形式：*(pa+4)。pa这时候代表的是数组首元素的首地址，假设为0x0000FF00，然后加上4个字符的偏移量，得到新的地址0x0000FF04。然后取出0x0000FF04 地址上的值。
//        2、以下标的形式：a[4]。编译器总是把以下标的形式的操作解析为以指针的形式的操作。a[4]这个操作会被解析成：a 作为数组首元素的首地址，然后加上中括号中4 个元素的偏移量，计算出新的地址，然后从新的地址中取出值。
         printf("\n%c,%c",*(pa+4),pa[4]);//5,5
//        由上面的分析，我们可以看到，指针和数组根本就是两个完全不一样的东西。只是它们都可以“以指针形式”或“以下标形式”进行访问。
//        一个是完全的匿名访问，一个是典型的具名+匿名访问。一定要注意的是这个“以XXX 的形式的访问”这种表达方式。
//        另外一个需要强调的是：上面所说的偏移量4代表的是4个元素，而不是4 个byte。
//        只不过这里刚好是char 类型数据1 个字符的大小就为1 个byte。
//        记住这个偏移量的单位是元素的个数而不是byte 数，在计算新地址时千万别弄错了。
        
        
        
//        指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。
//        数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。
        int *p1[10];
//      “[]”的优先级比“*”要高。p1先与“[]”结合，构成一个数组的定义，数组名为p1，int *修饰的是数组的内容，即数组的每个元素为int *类型。那现在我们清楚，这是一个数组，其包含10个指向int类型数据的指针元素，即指针数组。
        int (*p2)[10];
//      至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2构成一个指针的定义，指针变量名为p2，int修饰的是数组的内容，即数组的每个元素。
//        数组在这里并没有名字，是个匿名数组。那现在我们清楚p2是一个指针，它指向一个包含10 个int类型数据的数组，即数组指针。
        
        
//          a 和&a 的区别:
        int a[5]={1,2,3,4,5};//sieof(a)=5*4=20
        int *ptr=(int *)(&a+1);//&a=0x000000016fd53924,&a+1=0x000000016fd53924+sieof(a)=0x000000016fd53938(ptr指向a数组后的越界地址)
        printf("\n%d,%d",*(a+1),*(ptr-1));//2,5 *a=1 *(a+1)=2  ptr-1为指向上一个内存地址0x000000016fd53938-4=5
//        对指针进行加1 操作，得到的是下一个元素的地址，而不是原有地址值直接加1。所以，一个类型为T 的指针的移动，以sizeof(T) 为移动单位。
//        因此，对上题来说，a是一个一维数组，数组中有5 个元素； ptr是一个int型的指针。
//        &a + 1，其中&a表示取数组a的首地址，+1表示该地址的值加上sizeof(a)的值，即&a+5*sizeof(int)，也就是下一个数组的首地址，显然当前指针已经越过了数组的界限。
//        (int *)(&a+1): 则是把上一步计算出来的地址，强制转换为int * 类型，赋值给ptr。
//        *(a+1)，其中的a和&a 的值是一样的，但意思不一样！
//        a是数组首元素的首地址，也就是a[0]的首地址，
//        而&a是数组的首地址(其值等于数组第一个元素的首地址)，a+1是数组下一元素的首地址，即a[1]的首地址,而&a+1是下一个数组的首地址。所以*(a+1)输出为2；
//        *(ptr-1)，其中因为ptr是指向已越界的a[5]的，并且ptr 是int * 类型，所以*(ptr-1) 是指向a[4] ，输出为5。
        
        char b[5]={'A','B','C','D'};
        char (*p3)[5] = &b;//&b=ABCD
        char (*p4)[5] = b;//b=ABCD
        printf("\n%d,%d \n%s,%s",p3,p4,p3+1,p4+1);
//        毫无疑问，p3 和p4 都是数组指针，指向的是整个数组。&a 是整个数组的首地址，a是数组首元素的首地址，其值相同但意义不同。
//        在C 语言里，赋值符号“=”号两边的数据类型必须是相同的，如果不同需要显示或隐式的类型转换。
//        p3 这个定义的“=”号两边的数据类型完全一致，而p4 这个定义的“=”号两边的数据类型就不一致了。
//        左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针。在Visual C++6.0 上给出如下警告：
//        warning C4047: ‘initializing’ : ‘char (*)[5]‘ differs in levels of indirection from ‘char *’。
//        当然，这里虽然给出了警告，但由于&a 和a 的值一样，而变量作为右值时编译器只是取变量的值，所以运行并没有什么问题。不过我仍然警告你别这么用。
//        既然现在清楚了p3 和p4 都是指向整个数组的指针，那p3+1 和p4+1 的值就很好理解了。对指针进行+1操作，得到的是下一元素的地址b[5],其值越界未知
        
        //如果改变指针所指向的数组的大小，如：
        char (*p5)[2] = &b;//&b=ABCD
        char (*p6)[3] = b;//b=ABCD
        printf("\n%s,%s",p5+1,p6+1);//CD,D
        
        
        char (*p7)[4] = &b;
        char (*p8)[6] = b;
        printf("\n%s,%s",p7+1,p8+1);//结束符,越界未知
        
        
        int arr[4]={1,3,5,7};
        int *ptr1=(int *)(&arr+1);
        //        ptr1：将&arr+1 的值强制转换成int*类型，赋值给int* 类型的变量ptr1，ptr1肯定指到数组arr的下一个int类型数据了
        printf("\n%d",ptr1[-1]);
        //ptr1[-1]被解析成*(ptr1-1)，即ptr1 往后退4个byte。所以其值为7;
        
        int *ptr3=(int *)(arr+1);
        //        arr为首元素arr[0]的地址，+1表示为第2个元素的地址arr[1],所以*ptr3的值为3
        printf("\n%d=%d",ptr3,*ptr3);
        
        int *ptr2=(int *)((int)arr+1);
        
        //        ptr2：按照上面的讲解，(int)arr+1的值是元素arr[0]的第二个字节的地址。然后把这个地址强制转换成int*类型的值赋给ptr2，也就是说*ptr2的值应该为元素a[0]的第二个字节开始的连续4个byte 的内容。
        printf("\n%d",ptr2); //objc-c下打印*ptr2会失败，但从其指向的地址(0x000000006fdab945)来看=ptr3的地址(0x000000016fdab948)-3，是对的，指向了arr[0]的第2个字节的地址
        
        
        union check
        {
            int i;
            char ch;
        } c;
        c.i = 1;
        printf("\n%d",c.ch); //当前系统为大端模式这个函数返回c.ch!=1；如果为小端模式，函数返回c.ch==1 //iphone6(iOS9)下返回为1
        
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
